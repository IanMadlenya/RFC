= Binary Wire Format API v1.8
Peter Lawrey

=== Specification

[options="header"]
|===
| Title   | Binary Wire Format API                                                      
| Parent  | https://github.com/OpenHFT/RFC/blob/master/Wire-Format-API/                 
| URL     | https://github.com/OpenHFT/RFC/blob/master/Wire-Format-API/Binary           
| Latest  | https://github.com/OpenHFT/RFC/blob/master/Wire-Format-API/Binary/Binary-Wire-Format-API-1.8.adoc
| Editor  | Peter Lawrey
| License | Apache 2.0
| Change Process | Users issue Pull Requests for the Editor's consideration.
| Status  | In use
|===

=== Goals

The Binary Wire Format API is a binary one to one translation of the Text format.

WFA is designed to be high level description for Wire Formats to comply with.  Any Wire Format which complies with this RFC can be accessed through the same API.

This format should be automatically translatable to the Text (human readable) format.

=== Encoding Byte

For short fields, the first byte denotes the type of the field, for small numbers the value is encoded in the later 4 bits. For strings and fields the later 4 bits denote the length of the preceeding data. For large numerics or string/fields the special type is used see section below :

[options="header"]
|===
| comment                               | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| top three bits denotes a three Type   | x   | x   | x   |  x  |     |     |     |
| remaining bits denotes the size/value |     |     |     |     | x   | x  |  x   | x
|===

==== Types ( for small values )

[options="header"]
|===
| type   | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| Num (0-15)                            | 0   | 0   | 0   | 0   |     |     |     |
| Num (16-31)                           | 0   | 0   | 0   | 1   |     |     |     |
| Num (32-47)                           | 0   | 0   | 1   | 0   |     |     |     |
| Num (48-63)                           | 0   | 0   | 1   | 1   |     |     |     |
| Num (64-79)                           | 0   | 1   | 0   | 0   |     |     |     |
| Num (80-95)                           | 0   | 1   | 0   | 1   |     |     |     |
| Num (96-111)                          | 0   | 1   | 1   | 0   |     |     |     |
| Num (112-127)                         | 0   | 1   | 1   | 1   |     |     |     |
| Control Message                       | 1   | 0   | 0   | 0   |     |     |     |
| Decimal                               | 1   | 0   | 0   | 1   |     |     |     |
| Integer                               | 1   | 0   | 1   | 0   |     |     |     |
| Special                               | 1   | 0   | 1   | 1   |     |     |     |
| Field (0-15)                          | 1   | 1   | 0   | 0   |     |     |     |
| Field (16-31)                         | 1   | 1   | 0   | 1   |     |     |     |
| String (0-15)                         | 1   | 1   | 1   | 0   |     |     |     |
| String (16-31)                        | 1   | 1   | 1   | 1   |     |     |     |
|===

==== Definition of a field and a string

In the following uri

[source, yaml]
csp: //a-uri?view=map

'csp' is the Field.

And '//a-uri?view=map' is the String

=== Types ( for larger values )

the types use the Control Messages

[options="header"]
|===
| Control message                       | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| ( all higher bits are the same )                   | 1   | 0   | 0   | 0   |     |     |     |
| (0x80) - Nested Block 8bit len     | 1   | 0   | 0   | 0   | 0   | 0   | 0   |  0
| (0x81) - Nested Block 16bit len     | 1   | 0   | 0   | 0   | 0   | 0   | 0   |  1
| (0x82) - Nested Block 32bit len     | 1   | 0   | 0   | 0   | 0   | 0   | 1   |  0
| (0x8A) - byte[]                       | 1   | 0   | 0   | 0   | 1   | 0   | 1   |  0
| (0x8D) - long[]                       | 1   | 0   | 0   | 0   | 1   | 1   | 0   |  1
| (0x8E) - paddding with 32bit length   | 1   | 0   | 0   | 0   | 1   | 1   | 1   |  0
| (0x8F) - single padded byte           | 1   | 0   | 0   | 0   | 1   | 1   | 1   |  1
|===

Version 1.6 added 0x81

0x87, 0x88, 0x89 are reserved

=== Decimal

[options="header"]
|===
| Decimal message                       | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| ( all higher bits are the same )                    | 1   | 0   | 0   | 1   |     |     |     |
| (0x90) - 32bit floating point         | 1   | 0   | 0   | 1   | 0   | 0   | 0   |  0
| (0x91) - 64bit floating point         | 1   | 0   | 0   | 1   | 0   | 0   | 0   |  1
| (0x92) - fixed stop bit / 100.0      | 1   | 0   | 0   | 1   | 0   | 0   | 1   |  0
| (0x94) - fixed stop bit / 1e4         | 1   | 0   | 0   | 1   | 0   | 1   | 0   |  0
| (0x96) - fixed stop bit / 1e6         | 1   | 0   | 0   | 1   | 0   | 1   | 1   |  0
|===

Version 1.8 added 0x92, 0x94, 0x96

=== Integer

|===
| Integer message                      | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| ( all higher bits are the same )                    | 1   | 0   | 1   | 0   |     |     |     |
| (0xA0) - 128bit uuid                  | 1   | 0   | 1   | 0   | 0   | 0   | 0   |  0
| (0xA1) - unsigned 8bit int            | 1   | 0   | 1   | 0   | 0   | 0   | 0   |  1
| (0xA2) - unsigned 16bit int           | 1   | 0   | 1   | 0   | 0   | 0   | 1   |  0
| (0xA3) - unsigned 32bit int           | 1   | 0   | 1   | 0   | 0   | 0   | 1   |  1
| (0xA4) - signed 8bit int              | 1   | 0   | 1   | 0   | 0   | 1   | 0   |  0
| (0xA5) - signed 16bit int             | 1   | 0   | 1   | 0   | 0   | 1   | 0   |  1
| (0xA6) - signed 32bit int             | 1   | 0   | 1   | 0   | 0   | 1   | 1   |  0
| (0xA7) - signed 64bit int             | 1   | 0   | 1   | 0   | 0   | 1   | 1   |  1
| (0xA8) - delta set low 8bit - reserved      | 1   | 0   | 1   | 0   | 1   | 0   | 0   |  0
| (0xA9) - delta set low 16bit - reserved      | 1   | 0   | 1   | 0   | 1   | 0   | 0   |  1
| (0xAF) - signed 64bit int in base 16  | 1   | 0   | 1   | 0   | 1   | 1   | 1   |  1
|===

Version 1.6 added 0xAF

=== Special

[NOTE]
For <string> the string encode by default is a stop bit encoded len followed by a ISO-8851-9 string, see more on this at https://github.com/OpenHFT/RFC/blob/master/Stop-Bit-Encoding/

|===
| Special message                             | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| ( all higher bits are the same )            | 1   | 0   | 1   | 1   |     |     |     |
| (0xB0) - FALSE                              | 1   | 0   | 1   | 1   | 0   | 0   | 0   |  0
| (0xB1) - TRUE                               | 1   | 0   | 1   | 1   | 0   | 0   | 0   |  1
| (0xB2) - time UTC (long)                    | 1   | 0   | 1   | 1   | 0   | 0   | 1   |  0
| (0xB3) - Date (joda UTF8-Str)               | 1   | 0   | 1   | 1   | 0   | 0   | 1   |  1
| (0xB4) - DateTime (joda UTF8-Str)           | 1   | 0   | 1   | 1   | 0   | 1   | 0   |  0
| (0xB5) - ZonedDateTime (joda  {string})   | 1   | 0   | 1   | 1   | 0   | 1   | 0   |  1
| (0xB6) - type ( {type} +  {object})     | 1   | 0   | 1   | 1   | 0   | 1   | 1   |  0
| (0xB7) - field of stop bit length    | 1   | 0   | 1   | 1   | 0   | 1   | 1   |  1
| (0xB8) - string of stop bit encoded length | 1   | 0   | 1   | 1   | 1   | 0   | 0   |  1
| (0xB9) - Event Name, String of stop bit length  | 1   | 0   | 1   | 1   | 1   | 0   | 1   |  0
| (0xBA) - Field Number stop bit encoded | 1   | 0   | 1   | 1   | 1   | 0   | 1   |  1
| (0xBB) - NULL                               | 1   | 0   | 1   | 1   | 1   | 1   | 0   |  0
| (0xBC) - Type Literal with stop bit length | 1   | 0   | 1   | 1   | 1   | 1   | 0   |  0
| (0xBD) - Event which is an object           | 1   | 0   | 1   | 1   | 1   | 1   | 0   |  1
| (0xBE) - Comment  with stop bit length   | 1   | 0   | 1   | 1   | 1   | 1   | 1   |  0
|===

[NOTE]
( 0xBA ) - see examples on DeltaWire below

=== Control Messages

[options="header"]
|===
| type   | 7bit   | 6bit   | 5bit   | 4bit   | 3bit   | 2bit   | 1bit   | 0bit
| FieldAnchor ( 0x87 ) see examples on DeltaWire below                      | 1   | 0   | 0   | 0   | 0   | 1   | 1   | 1 |
|===


Version 1.6 added 0xBD

===  Delta Wire

DeltaWire is a compact form of binary wire.

==== Field Cache

The following covers field caching, the first time a field is sent a token is sent along with the field name, subsequent updates of this field will refer to the field via the field token, it wont again send the field. In this document we refer to this field token as the 'field token'


Assume we have the following Yaml
[source]
{hello: 1}

in Binary Wire this would encode to:

[source]
C5 68 65 6C 6C 6F 01

[options="header"]
|===
|hex | description
| 0xC5 | Field of Len 5
| 0x68 | ‘h’ as Ascii
| 0x65 | ‘e’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6F | ‘o’ as Ascii
| 0x01 | value of 1
|===

with DELTA binary this becomes:

[source]
87 00 05 68 65 6C 6C 6F 01

|===
| 0x87 |  Field Anchor - special control message to denote delta wire field
| 0x00 |  field token - see section below on 'Field Token Cache'
| 0x05 |  field len
| 0x68 | ‘h’ as Ascii
| 0x65 | ‘e’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6F | ‘o’ as Ascii
| 0x01 | value of 1
|===

If the same Field is sent again DeltaWire is a more compact format than Binary Wire, so the following :
[source]
{
	hello: 1,
	hello: 1,
    hello: 1
}

this becomes -  in binary wire:
[source]
C5 68 65 6C 6C 6F 01 C5  68 65 6C 6C 6F 01 C5  68 65 6C 6C 6F 01

and in delta wire :
[source]
87 00 05 68 65 6C 6C 6F  01 BA 00 01 BA 00 01

[options="header"]
|===
|hex | description
| 0x87 |  Field Anchor -  control message to denote delta wire field
| 0x00 |  field token - see section below on 'Field Token Cache'
| 0x05 |  field length
| 0x68 | ‘h’ as Ascii
| 0x65 | ‘e’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6C | ‘l’ as Ascii
| 0x6F | ‘o’ as Ascii
| 0xBA | Field Number  - special message to denote the next value is a field token
| 0x00 | field token
| 0x01 | value of 1
| 0xBA | Field Number  - special message to denote the next value is a field token
| 0x00 | field token
| 0x01 | value of 1
|===

==== Field Token Cache

A Messages sent with a 'Field Anchor', we should always cache relationship between the field token and its field.

So when the following delta binary is received :

87 00 05 68 65 6C 6C 6F

we cache the following relationship

.field token cache
[options="header"]
|===
| field token  | field
| 0   | hello
|===

each field is allocated a token, there is always a 1 to 1 relationship between the tokens and fields.

so if the following binary was received :

[source]
87 00 05 68 65 6C 6C 6F 01 87 01 05 77 6F 72 6C 64 01

then we would cache

.field token cache
[options="header"]
|===
| field token  | field
| 0   | hello
| 1   | world
|===

===== Overwriting of the Field Anchor

field tokens can be reused, so assume we had already received the following :

[source]
87 00 08 75 6E 69 76 65 72 73 65 01

.field token cache
|===
| field token   | field
| 0   | hello
| 1   | world
|===

if we then subsequently receive

[source]
87 01 08 75 6E 69 76 65  72 73 65 01

.field token cache
|===
| field token   | field
| 0   | hello
| 1   | universe
|===

we overwrite the existing cache entry  1=world and replace it with 1=universe

It we subsequently receive a message that sets field token 1 to the value of 2

BA 01 02

then this is setting the field universe to the value of 2

.yaml
[source]
{universe:2}

rather than

.yaml
[source]
{universe:2}

for this reason its important that all DELTA wire messages are read in order and no messages are skipped.


===  Sequences, Maps and Marshallables

the sequence area encoded using

[source]
0x82 <four byte unsigned len, this is the length in bytes of the encoded block of preceding data>

so if we were going to encode these simple 4 entries  shown below in text yaml )

[source]
{a,b,c,de}

 As binary wire this would encode to

[source]
0x82 0x09 0x00 0x00 0x00 0xE1 0x61 0xE1 0x62 0xE1 0x63 0xE2 0x64 0x65

|===
| byte | description
| 0x82 | denoting a nested structure
| 0x09 0x00 0x00 0x00 | the number of bytes of data to follow ( in little endian )
| 0xE1 | next element is a string of len 1
| 0x61 | 'a'
| 0xE1 | next element is a string of len 1
| 0x62 | 'b'
| 0xE1 | next element is a string of len 1
| 0x63 | 'c'
| 0xE2 | next element is a string of len 2
| 0x64 0x65 | 'de'
|===

[NOTE]
Although YAML treats sequences and maps differently, for binary wire we use similar encoding, its just they will hold different information

[source, yaml]
{f1: a, f2: de}

as binary wire this would encode to

[source]
0x82 0x0B 0x00 0x00 0x00 0xC2 0x66 0x31 0xE1 0x62 0xC2 0x66 0x32 0xE2 0x64 0x65

|===
| byte | description
| 0x82 | denoting a nested structure
| 0x0B 0x00 0x00 0x00 | the number of bytes of data to follow ( in little endian )
| 0xC2 |  next element is a field of len 2
| 0x66 0x31 | 'f1'
| 0xE1 | next element is a string of len 1
| 0x62 | 'b'
| 0xC2 | next element is a field of len 2
| 0x66 0x32 | 'f2'
| 0xE2 | next element is a string of len 2
| 0x64 0x65 | 'de'
|===

== Example

using this encoding described above, the following YAML

[source, yaml]
----
--- !!meta-data
csp: //path/service
tid: 123456789
--- !!data
entrySet: [
    {
    key: key-1,
    value: value-1
},
    {
    key: key-2,
    value: value-2
}
]
----

When encoded with BinaryWire would appear as:

[source]
00000000 1C 00 00 40 C3 63 73 70  EE 2F 2F 70 61 74 68 2F ···@·csp ·//path/
00000010 73 65 72 76 69 63 65 C3  74 69 64 A3 15 CD 5B 07 service· tid···[·
00000020 48 00 00 00 C8 65 6E 74  72 79 53 65 74 82 3A 00 H····ent rySet·:·
00000030 00 00 82 18 00 00 00 C3  6B 65 79 E5 6B 65 79 2D ········ key·key-
00000040 31 C5 76 61 6C 75 65 E7  76 61 6C 75 65 2D 31 82 1·value· value-1·
00000050 18 00 00 00 C3 6B 65 79  E5 6B 65 79 2D 32 C5 76 ·····key ·key-2·v
00000060 61 6C 75 65 E7 76 61 6C  75 65 2D 32             alue·val ue-2

this is the java code that created this this binary output above

[source, java]
----
@Test
public void testSequence() {
    Wire wire = createWire();
    writeMessage(wire);
    wire.flip();
    System.out.println(wire.bytes().toHexString());

    Wire twire = new TextWire(Bytes.elasticByteBuffer());
    writeMessage(twire);
    twire.flip();
    System.out.println(Wires.fromSizePrefixedBlobs(twire.bytes()));
}

private void writeMessage(Wire wire) {
    wire.writeDocument(true, w -> w
            .write("csp").text("//path/service")
            .write("tid").int64(123456789));
    wire.writeDocument(false, w -> w
            .write("entrySet").sequence(s -> {
                s.marshallable(m -> m
                        .write("key").text("key-1")
                        .write("value").text("value-1"));
                s.marshallable(m -> m
                        .write("key").text("key-2")
                        .write("value").text("value-2"));
            }));
}
----

=== Layout

The expected format is

- 4 bytes length with the meta-data bit set.
- 3-byte field + "csp"
- N-byte string + string
- 3-bytes field + "tid"
- integer value as a int64.

In the future we will make the tid to be smaller. possibly just a byte or 3 (uint16).

Q.Where would the nested be involved?

A.You might consider the whole document with its length a "nested" structure.
